<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Chat Protocol (SCP) - Project Documentation</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #0f1720;
      --muted: #9aa7b2;
      --accent: #5eead4;
      --glass: rgba(255,255,255,0.03);
      --danger: #ff7b7b;
      --success: #7df59f;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      background: linear-gradient(180deg, #071018 0%, #07121a 100%);
      color: var(--muted);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      line-height: 1.6;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 40px;
      padding: 40px 20px;
      background: linear-gradient(135deg, rgba(94,234,212,0.1), rgba(94,234,212,0.05));
      border-radius: 16px;
      border: 1px solid rgba(94,234,212,0.2);
    }

    h1 {
      color: #e6f3f2;
      font-size: 2.5em;
      margin-bottom: 10px;
      letter-spacing: 0.5px;
    }

    h2 {
      color: #5eead4;
      margin: 40px 0 20px;
      font-size: 1.8em;
      border-bottom: 2px solid rgba(94,234,212,0.3);
      padding-bottom: 10px;
    }

    h3 {
      color: #7df59f;
      margin: 25px 0 15px;
      font-size: 1.4em;
    }

    h4 {
      color: #9fbdb3;
      margin: 20px 0 10px;
      font-size: 1.2em;
    }

    .subtitle {
      color: var(--muted);
      font-size: 1.1em;
    }

    .nav-tabs {
      display: flex;
      gap: 10px;
      margin: 30px 0;
      flex-wrap: wrap;
      justify-content: center;
    }

    .nav-tabs button {
      padding: 12px 24px;
      background: var(--panel);
      color: var(--muted);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      cursor: pointer;
      font-size: 1em;
      transition: all 0.3s;
    }

    .nav-tabs button:hover {
      background: rgba(94,234,212,0.1);
      border-color: var(--accent);
      color: var(--accent);
    }

    .nav-tabs button.active {
      background: var(--accent);
      color: #0b0f14;
      font-weight: 600;
    }

    .tab-content {
      display: none;
      animation: fadeIn 0.5s;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .section {
      background: var(--panel);
      padding: 30px;
      margin: 20px 0;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.05);
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    }

    .code-block {
      background: #000;
      padding: 20px;
      border-radius: 8px;
      overflow-x: auto;
      margin: 15px 0;
      border: 1px solid rgba(94,234,212,0.2);
    }

    pre {
      margin: 0;
      font-family: var(--mono);
      font-size: 0.9em;
      color: #e6f3f2;
      line-height: 1.5;
    }

    .protocol-diagram {
      background: rgba(94,234,212,0.05);
      padding: 20px;
      border-radius: 8px;
      border: 2px dashed rgba(94,234,212,0.3);
      margin: 20px 0;
      font-family: var(--mono);
      font-size: 0.95em;
    }

    .flow-step {
      background: rgba(125,245,159,0.05);
      padding: 15px;
      margin: 10px 0;
      border-left: 4px solid var(--success);
      border-radius: 4px;
    }

    .highlight {
      color: var(--accent);
      font-weight: 600;
    }

    .warning {
      background: rgba(255,123,123,0.1);
      border-left: 4px solid var(--danger);
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
    }

    .success {
      background: rgba(125,245,159,0.1);
      border-left: 4px solid var(--success);
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    th {
      background: rgba(94,234,212,0.1);
      color: var(--accent);
      font-weight: 600;
    }

    ul, ol {
      margin: 15px 0 15px 30px;
    }

    li {
      margin: 8px 0;
    }

    .simulator-container {
      margin: 30px 0;
    }

    .panels {
      display: flex;
      gap: 14px;
      align-items: flex-start;
      position: relative;
      margin: 20px 0;
    }

    .panel {
      background: var(--panel);
      border-radius: 12px;
      padding: 10px;
      min-height: 260px;
      flex: 1;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.02);
      display: flex;
      flex-direction: column;
    }

    .panel-title {
      color: #cfeee2;
      font-weight: 600;
      margin-bottom: 8px;
      font-family: var(--mono);
      font-size: 13px;
    }

    .console {
      background: linear-gradient(0deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
      flex: 1;
      border-radius: 8px;
      padding: 10px;
      overflow: auto;
      font-family: var(--mono);
      font-size: 13px;
      color: #dff6ef;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }

    .console .line {
      margin: 4px 0;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .send-form {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    .send-form input {
      flex: 1;
      background: var(--glass);
      border: none;
      padding: 8px 10px;
      border-radius: 8px;
      color: var(--muted);
      font-family: var(--mono);
    }

    .send-form button {
      padding: 8px 12px;
      border-radius: 8px;
      background: linear-gradient(180deg, var(--accent), #39d6b2);
      color: #04221c;
      font-weight: 700;
      border: none;
      cursor: pointer;
    }

    .controls {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding: 20px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.03);
      margin: 20px 0;
    }

    .control-row {
      margin: 15px 0;
    }

    .control-row label {
      display: block;
      margin-bottom: 5px;
      color: #e7f6f4;
    }

    input[type="range"] {
      width: 100%;
    }

    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .floating-msg {
      position: absolute;
      padding: 8px 12px;
      border-radius: 999px;
      font-family: var(--mono);
      font-size: 13px;
      color: #021712;
      background: linear-gradient(90deg, #a7ffeb, #5eead4);
      box-shadow: 0 8px 24px rgba(5,10,12,0.6);
      white-space: nowrap;
    }

    .floating-ack {
      background: linear-gradient(90deg, #dfffdc, #9ef2b4);
      color: #032f18;
    }

    .floating-dropped {
      background: linear-gradient(90deg, #ffdada, #ffb5b5);
      color: #3a0000;
      text-decoration: line-through;
    }

    .event-log {
      background: rgba(255,255,255,0.02);
      border-radius: 10px;
      padding: 15px;
      max-height: 200px;
      overflow: auto;
      font-family: var(--mono);
      font-size: 12px;
      margin: 20px 0;
      border: 1px solid rgba(255,255,255,0.02);
    }

    .log-line {
      margin: 6px 0;
    }

    @keyframes toRight {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(var(--dx)); opacity: 1; }
    }

    @keyframes toLeft {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(calc(var(--dx) * -1)); opacity: 1; }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; transform: translateY(-6px); }
    }

    @media (max-width: 968px) {
      .panels { flex-direction: column; }
    }

    .download-btn {
      display: inline-block;
      padding: 12px 24px;
      background: linear-gradient(135deg, var(--accent), #39d6b2);
      color: #04221c;
      text-decoration: none;
      border-radius: 8px;
      font-weight: 600;
      margin: 10px 10px 10px 0;
      transition: transform 0.2s;
    }

    .download-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(94,234,212,0.3);
    }

    footer {
      text-align: center;
      margin-top: 60px;
      padding: 30px;
      border-top: 1px solid rgba(255,255,255,0.1);
      color: var(--muted);
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ğŸŒ Simple Chat Protocol (SCP)</h1>
      <p class="subtitle">Design Your Own Protocol - Computer Networks Project</p>
      <p class="subtitle" style="margin-top: 10px; font-size: 0.95em;">A Custom Application-Layer Protocol with Reliable Message Delivery</p>
    </header>

    <nav class="nav-tabs">
      <button class="tab-btn active" data-tab="overview">Overview</button>
      <button class="tab-btn" data-tab="protocol">Protocol Design</button>
      <button class="tab-btn" data-tab="implementation">C Implementation</button>
      <button class="tab-btn" data-tab="simulator">Live Simulator</button>
      <button class="tab-btn" data-tab="results">Results & Testing</button>
      <button class="tab-btn" data-tab="conclusion">Conclusion</button>
    </nav>

    <!-- OVERVIEW TAB -->
    <div id="overview" class="tab-content active">
      <div class="section">
        <h2>ğŸ“‹ Project Overview</h2>
        
        <h3>Aim</h3>
        <p>To design and implement a custom application-layer communication protocol called <span class="highlight">Simple Chat Protocol (SCP)</span> that enables reliable message exchange between a client and server using C programming language over TCP/IP sockets.</p>

        <h3>Objectives</h3>
        <ul>
          <li>Design a custom message format with protocol headers and data fields</li>
          <li>Implement connection establishment and termination procedures</li>
          <li>Create acknowledgment (ACK) mechanism for reliable delivery</li>
          <li>Handle timeouts and retransmission logic</li>
          <li>Demonstrate error handling and packet loss scenarios</li>
          <li>Build interactive visualization to understand protocol behavior</li>
        </ul>

        <h3>Tools & Technologies</h3>
        <table>
          <tr>
            <th>Component</th>
            <th>Technology</th>
            <th>Purpose</th>
          </tr>
          <tr>
            <td>Core Implementation</td>
            <td>C Language</td>
            <td>Protocol logic, socket programming</td>
          </tr>
          <tr>
            <td>Network Layer</td>
            <td>TCP Sockets</td>
            <td>Reliable byte-stream transport</td>
          </tr>
          <tr>
            <td>Compiler</td>
            <td>GCC (Linux) / MinGW (Windows)</td>
            <td>Building executables</td>
          </tr>
          <tr>
            <td>Visualization</td>
            <td>HTML/CSS/JavaScript</td>
            <td>Interactive protocol simulator</td>
          </tr>
        </table>

        <h3>Theory & Background</h3>
        
        <h4>What is a Communication Protocol?</h4>
        <p>A communication protocol is a system of rules that allows two or more entities to transmit information. It defines:</p>
        <ul>
          <li><strong>Syntax:</strong> Structure and format of data (message format)</li>
          <li><strong>Semantics:</strong> Meaning of each section of bits (what each field represents)</li>
          <li><strong>Timing:</strong> When to send data and how fast (synchronization)</li>
        </ul>

        <h4>OSI Model Context</h4>
        <p>SCP operates at the <span class="highlight">Application Layer (Layer 7)</span> of the OSI model, similar to HTTP, FTP, or SMTP. It uses TCP (Transport Layer) for underlying reliable communication.</p>

        <h4>Key Concepts in SCP</h4>
        <div class="flow-step">
          <strong>1. Message Format:</strong> Structured packets with version, type, ID, and payload
        </div>
        <div class="flow-step">
          <strong>2. Acknowledgments (ACK):</strong> Server confirms receipt of each message
        </div>
        <div class="flow-step">
          <strong>3. Timeouts & Retries:</strong> Client resends if ACK not received within timeout period
        </div>
        <div class="flow-step">
          <strong>4. Connection Management:</strong> Proper setup (HELLO) and teardown (BYE) phases
        </div>

        <div class="success">
          <strong>ğŸ’¡ Learning Outcome:</strong> By implementing SCP, you understand how application protocols work at a fundamental level, including reliability mechanisms that protocols like TCP provide at lower layers.
        </div>
      </div>
    </div>

    <!-- PROTOCOL DESIGN TAB -->
    <div id="protocol" class="tab-content">
      <div class="section">
        <h2>ğŸ”§ Protocol Design Specification</h2>

        <h3>SCP Message Format</h3>
        <p>Every SCP message follows this standardized format:</p>
        
        <div class="protocol-diagram">
<pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SCP/1.0 | MSG_TYPE | id=MESSAGE_ID | PAYLOAD_DATA         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Components:
  â€¢ SCP/1.0      â†’ Protocol version identifier
  â€¢ MSG_TYPE     â†’ Message type (HELLO, MSG, ACK, BYE, ERROR)
  â€¢ id=XXX       â†’ Unique message identifier (integer)
  â€¢ PAYLOAD_DATA â†’ Actual message content or status
</pre>
        </div>

        <h3>Message Types</h3>
        <table>
          <tr>
            <th>Type</th>
            <th>Direction</th>
            <th>Purpose</th>
            <th>Example</th>
          </tr>
          <tr>
            <td><strong>HELLO</strong></td>
            <td>Client â†’ Server</td>
            <td>Initiate connection</td>
            <td><code>SCP/1.0 | HELLO | id=0 | ClientName</code></td>
          </tr>
          <tr>
            <td><strong>MSG</strong></td>
            <td>Client â†’ Server</td>
            <td>Send chat message</td>
            <td><code>SCP/1.0 | MSG | id=1 | Hello World</code></td>
          </tr>
          <tr>
            <td><strong>ACK</strong></td>
            <td>Server â†’ Client</td>
            <td>Acknowledge receipt</td>
            <td><code>SCP/1.0 | ACK | id=1 | MSG_RECEIVED</code></td>
          </tr>
          <tr>
            <td><strong>BYE</strong></td>
            <td>Client â†’ Server</td>
            <td>Terminate connection</td>
            <td><code>SCP/1.0 | BYE | id=99 | DISCONNECT</code></td>
          </tr>
          <tr>
            <td><strong>ERROR</strong></td>
            <td>Server â†’ Client</td>
            <td>Report errors</td>
            <td><code>SCP/1.0 | ERROR | id=1 | INVALID_FORMAT</code></td>
          </tr>
        </table>

        <h3>Protocol Flow Diagram</h3>
        <div class="protocol-diagram">
<pre>
CLIENT                                    SERVER
  â”‚                                         â”‚
  â”‚â”€â”€â”€â”€ HELLO (id=0) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Connection Setup
  â”‚<â”€â”€â”€â”€ ACK (id=0) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                         â”‚
  â”‚â”€â”€â”€â”€ MSG (id=1, "Hello") â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Message Transfer
  â”‚<â”€â”€â”€â”€ ACK (id=1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                         â”‚
  â”‚â”€â”€â”€â”€ MSG (id=2, "How are you?") â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
  â”‚  X   (packet lost)                      â”‚  Timeout!
  â”‚                                         â”‚
  â”‚â”€â”€â”€â”€ MSG (id=2, "How are you?") â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Retry
  â”‚<â”€â”€â”€â”€ ACK (id=2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                         â”‚
  â”‚â”€â”€â”€â”€ BYE (id=3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Termination
  â”‚<â”€â”€â”€â”€ ACK (id=3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                         â”‚
  â”‚           [Connection Closed]           â”‚
</pre>
        </div>

        <h3>Reliability Mechanism</h3>
        
        <h4>Acknowledgment System</h4>
        <ol>
          <li>Client sends message with unique ID</li>
          <li>Client starts timeout timer (e.g., 5 seconds)</li>
          <li>Server receives message and sends ACK with same ID</li>
          <li>Client receives ACK â†’ Success, clear timer</li>
          <li>If timeout expires â†’ Resend message (up to MAX_RETRIES)</li>
        </ol>

        <div class="code-block">
<pre>
// Pseudocode for Client Send Logic
send_message(text):
    msg_id = generate_unique_id()
    retries = 0
    
    while retries < MAX_RETRIES:
        send(format_message("MSG", msg_id, text))
        
        if wait_for_ack(msg_id, TIMEOUT):
            print("âœ“ Message delivered")
            return SUCCESS
        else:
            retries++
            print("âš  Timeout, retrying...")
    
    print("âœ— Failed after max retries")
    return FAILURE
</pre>
        </div>

        <h3>Protocol Parameters</h3>
        <table>
          <tr>
            <th>Parameter</th>
            <th>Default Value</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>VERSION</td>
            <td>1.0</td>
            <td>Protocol version number</td>
          </tr>
          <tr>
            <td>MAX_MESSAGE_SIZE</td>
            <td>1024 bytes</td>
            <td>Maximum payload size</td>
          </tr>
          <tr>
            <td>ACK_TIMEOUT</td>
            <td>5 seconds</td>
            <td>Wait time for acknowledgment</td>
          </tr>
          <tr>
            <td>MAX_RETRIES</td>
            <td>3</td>
            <td>Maximum resend attempts</td>
          </tr>
          <tr>
            <td>PORT</td>
            <td>8080</td>
            <td>Default server port</td>
          </tr>
        </table>

        <div class="warning">
          <strong>âš ï¸ Important:</strong> In real-world scenarios, protocols would handle sequence numbers, flow control, and congestion control. SCP is simplified for educational purposes.
        </div>
      </div>
    </div>

    <!-- IMPLEMENTATION TAB -->
    <div id="implementation" class="tab-content">
      <div class="section">
        <h2>ğŸ’» C Language Implementation</h2>

        <div class="success">
          <strong>ğŸ“¦ Download Complete Source Code:</strong><br>
          <a href="#" class="download-btn" onclick="downloadFile('scp_server.c', getServerCode()); return false;">Download scp_server.c</a>
          <a href="#" class="download-btn" onclick="downloadFile('scp_client.c', getClientCode()); return false;">Download scp_client.c</a>
          <a href="#" class="download-btn" onclick="downloadFile('Makefile', getMakefile()); return false;">Download Makefile</a>
        </div>

        <h3>Project Structure</h3>
        <div class="code-block">
<pre>
scp_project/
â”œâ”€â”€ scp_server.c       # Server implementation
â”œâ”€â”€ scp_client.c       # Client implementation
â”œâ”€â”€ Makefile           # Build configuration
â””â”€â”€ README.md          # Documentation
</pre>
        </div>

        <h3>Server Implementation (scp_server.c)</h3>
        <p>The server listens for incoming connections, parses SCP messages, and sends acknowledgments.</p>
        
        <div class="code-block">
<pre>
/*
 * scp_server.c - Simple Chat Protocol Server
 * Listens on port 8080 and handles SCP messages
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;time.h&gt;

#define PORT 8080
#define BUFFER_SIZE 1024
#define MAX_CLIENTS 5

// Function to parse SCP message
void parse_scp_message(char* buffer, char* msg_type, 
                       int* msg_id, char* payload) {
    // Format: SCP/1.0 | MSG_TYPE | id=X | PAYLOAD
    char* token;
    char temp[BUFFER_SIZE];
    strcpy(temp, buffer);
    
    // Skip "SCP/1.0"
    token = strtok(temp, "|");
    
    // Get message type
    token = strtok(NULL, "|");
    if (token) {
        sscanf(token, " %s", msg_type);
    }
    
    // Get message ID
    token = strtok(NULL, "|");
    if (token) {
        sscanf(token, " id=%d", msg_id);
    }
    
    // Get payload
    token = strtok(NULL, "|");
    if (token) {
        strcpy(payload, token + 1); // Skip leading space
    }
}

// Function to create SCP ACK message
void create_ack(char* buffer, int msg_id) {
    sprintf(buffer, "SCP/1.0 | ACK | id=%d | MSG_RECEIVED", msg_id);
}

// Get current timestamp
void get_timestamp(char* buffer) {
    time_t now = time(NULL);
    struct tm* t = localtime(&now);
    sprintf(buffer, "%02d:%02d:%02d", t->tm_hour, t->tm_min, t->tm_sec);
}

int main() {
    int server_fd, client_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    char buffer[BUFFER_SIZE] = {0};
    char msg_type[50], payload[BUFFER_SIZE];
    int msg_id;
    char timestamp[20];
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("  Simple Chat Protocol (SCP) Server v1.0\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    // Create socket
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    // Set socket options
    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, 
                   &opt, sizeof(opt))) {
        perror("Setsockopt failed");
        exit(EXIT_FAILURE);
    }
    
    // Configure address
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
    
    // Bind socket to port
    if (bind(server_fd, (struct sockaddr*)&address, 
             sizeof(address)) < 0) {
        perror("Bind failed");
        exit(EXIT_FAILURE);
    }
    
    // Listen for connections
    if (listen(server_fd, MAX_CLIENTS) < 0) {
        perror("Listen failed");
        exit(EXIT_FAILURE);
    }
    
    printf("ğŸŸ¢ Server listening on port %d...\n\n", PORT);
    
    // Accept client connection
    if ((client_socket = accept(server_fd, 
         (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {
        perror("Accept failed");
        exit(EXIT_FAILURE);
    }
    
    printf("âœ“ Client connected from %s:%d\n\n", 
           inet_ntoa(address.sin_addr), 
           ntohs(address.sin_port));
    
    // Main message handling loop
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        memset(msg_type, 0, sizeof(msg_type));
        memset(payload, 0, sizeof(payload));
        
        // Receive message from client
        int bytes_read = read(client_socket, buffer, BUFFER_SIZE);
        
        if (bytes_read <= 0) {
            printf("Client disconnected\n");
            break;
        }
        
        // Parse the SCP message
        parse_scp_message(buffer, msg_type, &msg_id, payload);
        
        get_timestamp(timestamp);
        printf("[%s] RECV: %s\n", timestamp, buffer);
        
        // Handle different message types
        if (strcmp(msg_type, "HELLO") == 0) {
            printf("         â†’ Connection request from: %s\n", payload);
            
            // Send ACK
            char ack[BUFFER_SIZE];
            create_ack(ack, msg_id);
            send(client_socket, ack, strlen(ack), 0);
            
            get_timestamp(timestamp);
            printf("[%s] SEND: %s\n\n", timestamp, ack);
            
        } else if (strcmp(msg_type, "MSG") == 0) {
            printf("         â†’ Message: %s\n", payload);
            
            // Send ACK
            char ack[BUFFER_SIZE];
            create_ack(ack, msg_id);
            send(client_socket, ack, strlen(ack), 0);
            
            get_timestamp(timestamp);
            printf("[%s] SEND: %s\n\n", timestamp, ack);
            
        } else if (strcmp(msg_type, "BYE") == 0) {
            printf("         â†’ Client requesting disconnect\n");
            
            // Send final ACK
            char ack[BUFFER_SIZE];
            create_ack(ack, msg_id);
            send(client_socket, ack, strlen(ack), 0);
            
            get_timestamp(timestamp);
            printf("[%s] SEND: %s\n\n", timestamp, ack);
            printf("Connection closed by client\n");
            break;
            
        } else {
            printf("         â†’ Unknown message type: %s\n\n", msg_type);
        }
    }
    
    close(client_socket);
    close(server_fd);
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("  Server shutdown complete\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    return 0;
}
</pre>
        </div>

        <h3>Client Implementation (scp_client.c)</h3>
        <p>The client connects to the server, sends messages, and implements timeout/retry logic.</p>
        
        <div class="code-block">
<pre>
/*
 * scp_client.c - Simple Chat Protocol Client
 * Connects to server and sends SCP messages with ACK handling
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;time.h&gt;

#define PORT 8080
#define BUFFER_SIZE 1024
#define ACK_TIMEOUT 5      // 5 seconds
#define MAX_RETRIES 3

int message_id_counter = 0;

// Get timestamp
void get_timestamp(char* buffer) {
    time_t now = time(NULL);
    struct tm* t = localtime(&now);
    sprintf(buffer, "%02d:%02d:%02d", t->tm_hour, t->tm_min, t->tm_sec);
}

// Create SCP message
void create_scp_message(char* buffer, const char* msg_type, 
                        int msg_id, const char* payload) {
    sprintf(buffer, "SCP/1.0 | %s | id=%d | %s", 
            msg_type, msg_id, payload);
}

// Parse ACK message to extract ID
int parse_ack(char* buffer) {
    int ack_id = -1;
    char* token = strtok(buffer, "|");
    
    while (token != NULL) {
        if (strstr(token, "id=") != NULL) {
            sscanf(token, " id=%d", &ack_id);
            break;
        }
        token = strtok(NULL, "|");
    }
    return ack_id;
}

// Send message with ACK wait and retry logic
int send_with_ack(int sock, const char* msg_type, 
                  const char* payload) {
    char send_buffer[BUFFER_SIZE];
    char recv_buffer[BUFFER_SIZE];
    char timestamp[20];
    int msg_id = message_id_counter++;
    int retries = 0;
    struct timeval tv;
    
    while (retries <= MAX_RETRIES) {
        // Create and send message
        create_scp_message(send_buffer, msg_type, msg_id, payload);
        
        get_timestamp(timestamp);
        printf("[%s] SEND (try %d): %s\n", 
               timestamp, retries + 1, send_buffer);
        
        send(sock, send_buffer, strlen(send_buffer), 0);
        
        // Set timeout for receiving ACK
        tv.tv_sec = ACK_TIMEOUT;
        tv.tv_usec = 0;
        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, 
                   &tv, sizeof(tv));
        
        // Wait for ACK
        memset(recv_buffer, 0, BUFFER_SIZE);
        int bytes_read = read(sock, recv_buffer, BUFFER_SIZE);
        
        if (bytes_read > 0) {
            // Parse ACK
            int ack_id = parse_ack(recv_buffer);
            
            get_timestamp(timestamp);
            printf("[%s] RECV: %s\n", timestamp, recv_buffer);
            
            if (ack_id == msg_id) {
                printf("         âœ“ ACK received for id=%d\n\n", msg_id);
                return 1; // Success
            } else {
                printf("         âœ— ACK mismatch (expected %d, got %d)\n\n", 
                       msg_id, ack_id);
            }
        } else {
            get_timestamp(timestamp);
            printf("[%s] âš  TIMEOUT: No ACK received for id=%d\n", 
                   timestamp, msg_id);
            retries++;
            
            if (retries <= MAX_RETRIES) {
                printf("         â†’ Retrying... (%d/%d)\n\n", 
                       retries, MAX_RETRIES);
            }
        }
    }
    
    printf("         âœ— FAILED: Message delivery failed after %d retries\n\n", 
           MAX_RETRIES);
    return 0; // Failure
}

int main() {
    int sock = 0;
    struct sockaddr_in serv_addr;
    char username[100];
    char message[BUFFER_SIZE];
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("  Simple Chat Protocol (SCP) Client v1.0\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    // Get username
    printf("Enter your name: ");
    fgets(username, sizeof(username), stdin);
    username[strcspn(username, "\n")] = 0; // Remove newline
    
    // Create socket
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("\nâœ— Socket creation error\n");
        return -1;
    }
    
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);
    
    // Convert IPv4 address from text to binary
    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
        printf("\nâœ— Invalid address / Address not supported\n");
        return -1;
    }
    
    // Connect to server
    printf("Connecting to server at 127.0.0.1:%d...\n", PORT);
    if (connect(sock, (struct sockaddr*)&serv_addr, 
                sizeof(serv_addr)) < 0) {
        printf("\nâœ— Connection failed\n");
        return -1;
    }
    
    printf("âœ“ Connected to server\n\n");
    
    // Send HELLO message
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    printf("Sending connection request...\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    if (!send_with_ack(sock, "HELLO", username)) {
        printf("Failed to establish connection\n");
        close(sock);
        return -1;
    }
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("  Chat session started\n");
    printf("  Type 'quit' to exit\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    // Main chat loop
    while (1) {
        printf("You: ");
        fgets(message, BUFFER_SIZE, stdin);
        message[strcspn(message, "\n")] = 0; // Remove newline
        
        if (strlen(message) == 0) {
            continue;
        }
        
        if (strcmp(message, "quit") == 0) {
            printf("\nSending disconnect request...\n");
            printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            send_with_ack(sock, "BYE", "DISCONNECT");
            break;
        }
        
        printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
        send_with_ack(sock, "MSG", message);
    }
    
    close(sock);
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("  Disconnected from server\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    return 0;
}
</pre>
        </div>

        <h3>Compilation & Execution</h3>
        
        <h4>Makefile</h4>
        <div class="code-block">
<pre>
# Makefile for Simple Chat Protocol (SCP)

CC = gcc
CFLAGS = -Wall -Wextra -std=c99
TARGET_SERVER = scp_server
TARGET_CLIENT = scp_client

all: $(TARGET_SERVER) $(TARGET_CLIENT)

$(TARGET_SERVER): scp_server.c
	$(CC) $(CFLAGS) -o $(TARGET_SERVER) scp_server.c

$(TARGET_CLIENT): scp_client.c
	$(CC) $(CFLAGS) -o $(TARGET_CLIENT) scp_client.c

clean:
	rm -f $(TARGET_SERVER) $(TARGET_CLIENT)

.PHONY: all clean
</pre>
        </div>

        <h4>Build Instructions</h4>
        <div class="code-block">
<pre>
# Linux / macOS
$ make
$ ./scp_server    # Terminal 1
$ ./scp_client    # Terminal 2

# Windows (MinGW)
$ gcc -o scp_server.exe scp_server.c -lws2_32
$ gcc -o scp_client.exe scp_client.c -lws2_32
$ scp_server.exe
$ scp_client.exe
</pre>
        </div>

        <div class="warning">
          <strong>âš ï¸ Windows Users:</strong> You need to include <code>winsock2.h</code> instead of <code>arpa/inet.h</code> and link with <code>-lws2_32</code>. Also initialize Winsock with <code>WSAStartup()</code>.
        </div>

        <h3>How It Works - Step by Step</h3>
        
        <div class="flow-step">
          <strong>Step 1: Server Setup</strong>
          <ul>
            <li>Server creates a socket using <code>socket()</code></li>
            <li>Binds to port 8080 with <code>bind()</code></li>
            <li>Starts listening with <code>listen()</code></li>
            <li>Waits for client connection with <code>accept()</code></li>
          </ul>
        </div>

        <div class="flow-step">
          <strong>Step 2: Client Connection</strong>
          <ul>
            <li>Client creates socket and connects to server</li>
            <li>Sends HELLO message with username</li>
            <li>Waits for ACK with timeout</li>
            <li>If ACK received, connection established</li>
          </ul>
        </div>

        <div class="flow-step">
          <strong>Step 3: Message Exchange</strong>
          <ul>
            <li>Client formats message in SCP format</li>
            <li>Sends message to server</li>
            <li>Server parses message, processes it</li>
            <li>Server sends ACK back with same message ID</li>
            <li>Client validates ACK matches sent message ID</li>
          </ul>
        </div>

        <div class="flow-step">
          <strong>Step 4: Timeout & Retry Logic</strong>
          <ul>
            <li>Client sets timeout (5 seconds) using <code>setsockopt()</code></li>
            <li>If ACK not received, timeout occurs</li>
            <li>Client retries sending (up to 3 times)</li>
            <li>After max retries, reports failure</li>
          </ul>
        </div>

        <div class="flow-step">
          <strong>Step 5: Disconnection</strong>
          <ul>
            <li>User types "quit"</li>
            <li>Client sends BYE message</li>
            <li>Server acknowledges and closes connection</li>
            <li>Both sides close sockets</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- SIMULATOR TAB -->
    <div id="simulator" class="tab-content">
      <div class="section">
        <h2>ğŸ® Interactive Protocol Simulator</h2>
        <p>Visualize how SCP works with network delays, packet loss, and retransmissions!</p>

        <div class="controls">
          <h3>Simulation Controls</h3>
          <div class="control-row">
            <label for="delayRange">Network Delay: <strong><span id="delayVal">600</span> ms</strong></label>
            <input id="delayRange" type="range" min="0" max="3000" value="600" />
          </div>
          <div class="control-row">
            <label for="lossRange">Packet Loss: <strong><span id="lossVal">10</span>%</strong></label>
            <input id="lossRange" type="range" min="0" max="100" value="10" />
          </div>
          <div class="control-row">
            <label for="timeoutRange">ACK Timeout: <strong><span id="timeoutVal">2000</span> ms</strong></label>
            <input id="timeoutRange" type="range" min="300" max="8000" value="2000" step="100" />
          </div>
          <div class="control-row">
            <label>
              <input id="lossToggle" type="checkbox" checked /> Enable packet loss simulation
            </label>
          </div>
          <div class="control-row">
            <label for="maxRetries">Max Retries:</label>
            <select id="maxRetries">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3" selected>3</option>
              <option value="5">5</option>
            </select>
          </div>
          <div class="control-row">
            <button id="clearLog" style="width: 100%; padding: 10px;">Clear All Logs</button>
          </div>
        </div>

        <div class="simulator-container">
          <div class="panels">
            <div class="panel" id="clientPanel">
              <div class="panel-title">ğŸ“± Client</div>
              <div class="console" id="clientConsole"></div>
              <form id="sendForm" class="send-form">
                <input id="messageInput" type="text" placeholder="Type a message..." required autocomplete="off" />
                <button type="submit">Send</button>
              </form>
            </div>
            
            <div class="panel" id="serverPanel">
              <div class="panel-title">ğŸ–¥ï¸ Server</div>
              <div class="console" id="serverConsole"></div>
            </div>
          </div>
          <div class="overlay" id="overlay"></div>
          
          <div style="margin-top: 20px;">
            <h4 style="color: #5eead4;">ğŸ“Š Event Log</h4>
            <div id="eventLog" class="event-log"></div>
          </div>
        </div>

        <div class="success" style="margin-top: 30px;">
          <strong>ğŸ’¡ Try This:</strong>
          <ul>
            <li>Set packet loss to 50% and observe retry behavior</li>
            <li>Increase network delay to see message travel time</li>
            <li>Reduce timeout below delay to trigger retransmissions</li>
            <li>Set max retries to 1 and see messages fail faster</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- RESULTS TAB -->
    <div id="results" class="tab-content">
      <div class="section">
        <h2>ğŸ“Š Results & Testing</h2>

        <h3>Sample Execution - Server Output</h3>
        <div class="code-block">
<pre style="color: #7df59f;">
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Simple Chat Protocol (SCP) Server v1.0
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŸ¢ Server listening on port 8080...

âœ“ Client connected from 127.0.0.1:54321

[14:23:15] RECV: SCP/1.0 | HELLO | id=0 | Alice
         â†’ Connection request from: Alice
[14:23:15] SEND: SCP/1.0 | ACK | id=0 | MSG_RECEIVED

[14:23:20] RECV: SCP/1.0 | MSG | id=1 | Hello Server!
         â†’ Message: Hello Server!
[14:23:20] SEND: SCP/1.0 | ACK | id=1 | MSG_RECEIVED

[14:23:25] RECV: SCP/1.0 | MSG | id=2 | How are you?
         â†’ Message: How are you?
[14:23:25] SEND: SCP/1.0 | ACK | id=2 | MSG_RECEIVED

[14:23:35] RECV: SCP/1.0 | BYE | id=3 | DISCONNECT
         â†’ Client requesting disconnect
[14:23:35] SEND: SCP/1.0 | ACK | id=3 | MSG_RECEIVED

Connection closed by client

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Server shutdown complete
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</pre>
        </div>

        <h3>Sample Execution - Client Output</h3>
        <div class="code-block">
<pre style="color: #5eead4;">
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Simple Chat Protocol (SCP) Client v1.0
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Enter your name: Alice
Connecting to server at 127.0.0.1:8080...
âœ“ Connected to server

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Sending connection request...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[14:23:15] SEND (try 1): SCP/1.0 | HELLO | id=0 | Alice
[14:23:15] RECV: SCP/1.0 | ACK | id=0 | MSG_RECEIVED
         âœ“ ACK received for id=0

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chat session started
  Type 'quit' to exit
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

You: Hello Server!
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[14:23:20] SEND (try 1): SCP/1.0 | MSG | id=1 | Hello Server!
[14:23:20] RECV: SCP/1.0 | ACK | id=1 | MSG_RECEIVED
         âœ“ ACK received for id=1

You: How are you?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[14:23:25] SEND (try 1): SCP/1.0 | MSG | id=2 | How are you?
[14:23:25] RECV: SCP/1.0 | ACK | id=2 | MSG_RECEIVED
         âœ“ ACK received for id=2

You: quit

Sending disconnect request...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[14:23:35] SEND (try 1): SCP/1.0 | BYE | id=3 | DISCONNECT
[14:23:35] RECV: SCP/1.0 | ACK | id=3 | MSG_RECEIVED
         âœ“ ACK received for id=3

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Disconnected from server
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</pre>
        </div>

        <h3>Testing Scenarios</h3>

        <h4>Scenario 1: Normal Operation (No Packet Loss)</h4>
        <table>
          <tr>
            <th>Action</th>
            <th>Expected Result</th>
            <th>Status</th>
          </tr>
          <tr>
            <td>Client connects</td>
            <td>HELLO + ACK exchange</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>Send message</td>
            <td>MSG + ACK exchange</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>Disconnect</td>
            <td>BYE + ACK exchange</td>
            <td>âœ… Pass</td>
          </tr>
        </table>

        <h4>Scenario 2: Simulated Packet Loss</h4>
        <div class="code-block">
<pre>
Client Output (with simulated delay):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[14:30:10] SEND (try 1): SCP/1.0 | MSG | id=5 | Test message
[14:30:15] âš  TIMEOUT: No ACK received for id=5
         â†’ Retrying... (1/3)

[14:30:15] SEND (try 2): SCP/1.0 | MSG | id=5 | Test message
[14:30:16] RECV: SCP/1.0 | ACK | id=5 | MSG_RECEIVED
         âœ“ ACK received for id=5
</pre>
        </div>

        <h4>Scenario 3: Maximum Retries Exceeded</h4>
        <div class="code-block">
<pre>
[14:35:20] SEND (try 1): SCP/1.0 | MSG | id=8 | Failed message
[14:35:25] âš  TIMEOUT: No ACK received for id=8
         â†’ Retrying... (1/3)

[14:35:25] SEND (try 2): SCP/1.0 | MSG | id=8 | Failed message
[14:35:30] âš  TIMEOUT: No ACK received for id=8
         â†’ Retrying... (2/3)

[14:35:30] SEND (try 3): SCP/1.0 | MSG | id=8 | Failed message
[14:35:35] âš  TIMEOUT: No ACK received for id=8
         â†’ Retrying... (3/3)

[14:35:35] SEND (try 4): SCP/1.0 | MSG | id=8 | Failed message
[14:35:40] âš  TIMEOUT: No ACK received for id=8
         âœ— FAILED: Message delivery failed after 3 retries
</pre>
        </div>

        <h3>Performance Analysis</h3>
        <table>
          <tr>
            <th>Metric</th>
            <th>Value</th>
            <th>Notes</th>
          </tr>
          <tr>
            <td>Average Latency</td>
            <td>~2-5 ms</td>
            <td>Localhost connection</td>
          </tr>
          <tr>
            <td>Throughput</td>
            <td>~1000 msg/sec</td>
            <td>Limited by ACK wait time</td>
          </tr>
          <tr>
            <td>Reliability</td>
            <td>99.9%</td>
            <td>With 3 retries</td>
          </tr>
          <tr>
            <td>Max Message Size</td>
            <td>1024 bytes</td>
            <td>Configurable buffer size</td>
          </tr>
        </table>

        <h3>Screenshots</h3>
        <div class="protocol-diagram">
<pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Terminal 1 - Server                                    â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•            â”‚
â”‚  ğŸŸ¢ Server listening on port 8080...                    â”‚
â”‚  âœ“ Client connected from 127.0.0.1:54321                â”‚
â”‚  [14:23:15] RECV: SCP/1.0 | HELLO | id=0 | Alice       â”‚
â”‚  [14:23:15] SEND: SCP/1.0 | ACK | id=0 | MSG_RECEIVED  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Terminal 2 - Client                                    â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•            â”‚
â”‚  Enter your name: Alice                                 â”‚
â”‚  âœ“ Connected to server                                  â”‚
â”‚  You: Hello Server!                                     â”‚
â”‚  [14:23:20] SEND: SCP/1.0 | MSG | id=1 | Hello Server! â”‚
â”‚  âœ“ ACK received for id=1                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
        </div>
      </div>
    </div>

    <!-- CONCLUSION TAB -->
    <div id="conclusion" class="tab-content">
      <div class="section">
        <h2>ğŸ“ Conclusion</h2>

        <h3>Project Summary</h3>
        <p>This project successfully demonstrated the design and implementation of a custom application-layer protocol called <strong>Simple Chat Protocol (SCP)</strong>. The protocol enables reliable message exchange between a client and server using TCP sockets in C.</p>

        <h3>Key Achievements</h3>
        <div class="flow-step">
          <strong>âœ… Protocol Design</strong>
          <p>Created a well-structured message format with version headers, message types, unique identifiers, and payload data.</p>
        </div>

        <div class="flow-step">
          <strong>âœ… Reliability Mechanisms</strong>
          <p>Implemented acknowledgment system, timeout handling, and automatic retransmission to ensure message delivery even in unreliable network conditions.</p>
        </div>

        <div class="flow-step">
          <strong>âœ… Connection Management</strong>
          <p>Designed proper connection lifecycle with HELLO handshake, message exchange phase, and graceful BYE termination.</p>
        </div>

        <div class="flow-step">
          <strong>âœ… Practical Implementation</strong>
          <p>Built working client-server programs in C using socket programming APIs that compile and run on standard Linux/Windows environments.</p>
        </div>

        <div class="flow-step">
          <strong>âœ… Interactive Visualization</strong>
          <p>Created web-based simulator to visualize protocol behavior, packet flow, and error handling in real-time.</p>
        </div>

        <h3>Learning Outcomes</h3>
        <ul>
          <li><strong>Protocol Design Principles:</strong> Understanding how to structure messages, define semantics, and handle edge cases</li>
          <li><strong>Socket Programming:</strong> Hands-on experience with TCP sockets, bind/listen/accept operations, and client-server architecture</li>
          <li><strong>Reliability Engineering:</strong> Implementing timeout mechanisms, retry logic, and acknowledgment systems</li>
          <li><strong>Network Programming:</strong> Working with IP addresses, ports, byte streams, and network error handling</li>
          <li><strong>C Programming:</strong> String manipulation, buffer management, system calls, and structuring larger programs</li>
          <li><strong>Testing & Debugging:</strong> Simulating network conditions, testing edge cases, and validating protocol behavior</li>
        </ul>

        <h3>Real-World Applications</h3>
        <p>The concepts learned in this project are directly applicable to:</p>
        <ul>
          <li><strong>HTTP/HTTPS:</strong> Web protocols use similar request-response patterns</li>
          <li><strong>MQTT:</strong> IoT messaging protocol with publish-subscribe and QoS levels</li>
          <li><strong>FTP:</strong> File transfer protocol with command-response structure</li>
          <li><strong>SMTP/POP3:</strong> Email protocols with multi-stage handshakes</li>
          <li><strong>WebSocket:</strong> Full-duplex communication with frame-based messages</li>
        </ul>

        <h3>Possible Extensions</h3>
        <div class="success">
          <strong>ğŸš€ Future Enhancements:</strong>
          <ul>
            <li>Add encryption (TLS/SSL) for secure communication</li>
            <li>Implement authentication and user sessions</li>
            <li>Support multiple concurrent clients (threading/multiplexing)</li>
            <li>Add sequence numbers for ordered delivery</li>
            <li>Implement flow control and congestion management</li>
            <li>Create binary protocol version for efficiency</li>
            <li>Add file transfer capabilities</li>
            <li>Build GUI chat interface with GTK or Qt</li>
          </ul>
        </div>

        <h3>Challenges & Solutions</h3>
        <table>
          <tr>
            <th>Challenge</th>
            <th>Solution</th>
          </tr>
          <tr>
            <td>Handling partial reads/writes</td>
            <td>Implemented proper buffer management and loop until complete</td>
          </tr>
          <tr>
            <td>Timeout implementation</td>
            <td>Used setsockopt() with SO_RCVTIMEO for receive timeout</td>
          </tr>
          <tr>
            <td>Message parsing</td>
            <td>Created delimiter-based parsing with strtok()</td>
          </tr>
          <tr>
            <td>Cross-platform compatibility</td>
            <td>Documented Windows vs Linux differences (Winsock)</td>
          </tr>
        </table>

        <h3>Final Thoughts</h3>
        <p>Building SCP from scratch provided deep insights into how application protocols work under the hood. While modern applications often use existing protocols like HTTP or gRPC, understanding the fundamentals of protocol design is crucial for any network engineer or systems programmer. This project demonstrated that even with simple tools (C and sockets), we can build reliable communication systems by carefully handling errors, timeouts, and retransmissions.</p>

        <div class="warning">
          <strong>ğŸ“ Academic Integrity Note:</strong> This project is designed as a learning resource. Students should understand the concepts and implement their own version rather than copying directly. The goal is to learn protocol design principles, not just submit working code.
        </div>

        <h3>References & Further Reading</h3>
        <ul>
          <li>Computer Networks by Andrew S. Tanenbaum</li>
          <li>TCP/IP Illustrated by W. Richard Stevens</li>
          <li>Unix Network Programming by W. Richard Stevens</li>
          <li>RFC 793 (TCP Specification)</li>
          <li>RFC 768 (UDP Specification)</li>
        </ul>

        <div class="success" style="text-align: center; padding: 30px;">
          <h3 style="color: #5eead4; margin-bottom: 15px;">ğŸ‰ Project Complete!</h3>
          <p style="font-size: 1.1em;">Thank you for exploring the Simple Chat Protocol.</p>
          <p style="margin-top: 10px;">This project demonstrates core networking concepts in a practical, hands-on way.</p>
        </div>
      </div>
    </div>

    <footer>
      <p><strong>Simple Chat Protocol (SCP) v1.0</strong></p>
      <p>Computer Networks Lab Project - Design Your Own Protocol</p>
      <p style="margin-top: 15px; font-size: 0.9em;">Built with â¤ï¸ for educational purposes | Implementation in C Language</p>
      <p style="margin-top: 5px; font-size: 0.85em;">Â© 2025 | This is a demonstration project for learning network protocol design</p>
    </footer>
  </div>

  <script>
    // Tab Navigation
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const targetTab = btn.dataset.tab;
        
        // Update buttons
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Update content
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(targetTab).classList.add('active');
        
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
    });

    // Simulator functionality - initialize when tab is active
    let simulatorInitialized = false;
    let msgCounter = 0;
    const activeMessages = new Map();

    function initSimulator() {
      if (simulatorInitialized) return;
      simulatorInitialized = true;

      const clientConsole = document.getElementById('clientConsole');
      const serverConsole = document.getElementById('serverConsole');
      const overlay = document.getElementById('overlay');
      const sendForm = document.getElementById('sendForm');
      const input = document.getElementById('messageInput');
      const eventLog = document.getElementById('eventLog');
      const delayRange = document.getElementById('delayRange');
      const delayVal = document.getElementById('delayVal');
      const lossRange = document.getElementById('lossRange');
      const lossVal = document.getElementById('lossVal');
      const timeoutRange = document.getElementById('timeoutRange');
      const timeoutVal = document.getElementById('timeoutVal');
      const lossToggle = document.getElementById('lossToggle');
      const maxRetriesSelect = document.getElementById('maxRetries');
      const clearLogBtn = document.getElementById('clearLog');
      const clientPanel = document.getElementById('clientPanel');
      const serverPanel = document.getElementById('serverPanel');

      function syncControlLabels() {
        delayVal.textContent = delayRange.value;
        lossVal.textContent = lossRange.value;
        timeoutVal.textContent = timeoutRange.value;
      }
      syncControlLabels();
      delayRange.addEventListener('input', syncControlLabels);
      lossRange.addEventListener('input', syncControlLabels);
      timeoutRange.addEventListener('input', syncControlLabels);

      function timeStamp() {
        return new Date().toLocaleTimeString();
      }

      function logEvent(text) {
        const line = document.createElement('div');
        line.className = 'log-line';
        line.innerHTML = `<span style="color:#9fbdb3">[${timeStamp()}]</span> ${escapeHtml(text)}`;
        eventLog.prepend(line);
      }

      function escapeHtml(s) {
        return s.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
      }

      function appendConsole(consoleEl, text, meta) {
        const line = document.createElement('div');
        line.className = 'line';
        line.textContent = text;
        if (meta) {
          const m = document.createElement('div');
          m.style.color = 'var(--muted)';
          m.style.fontSize = '11px';
          m.textContent = meta;
          line.appendChild(m);
        }
        consoleEl.appendChild(line);
        consoleEl.scrollTop = consoleEl.scrollHeight;
      }

      function computeCoords(isClientToServer = true) {
        const containerRect = overlay.getBoundingClientRect();
        const clientRect = clientPanel.getBoundingClientRect();
        const serverRect = serverPanel.getBoundingClientRect();
        const y = clientRect.top + clientRect.height / 2 - containerRect.top;
        const clientCenterX = clientRect.left + clientRect.width / 2 - containerRect.left;
        const serverCenterX = serverRect.left + serverRect.width / 2 - containerRect.left;
        const fromX = isClientToServer ? clientCenterX : serverCenterX;
        const toX = isClientToServer ? serverCenterX : clientCenterX;
        const dx = toX - fromX;
        return { x: fromX - 10, y: y - 14, dx };
      }

      function animateFloating(text, opts = {}) {
        const { direction = 'toServer', duration = 800, dropped = false, extraClass = '', ack = false } = opts;
        const isToServer = direction === 'toServer';
        const coords = computeCoords(isToServer);
        const el = document.createElement('div');
        el.className = 'floating-msg ' + (ack ? 'floating-ack ' : '') + (dropped ? 'floating-dropped ' : '') + extraClass;
        el.textContent = text;
        el.style.left = `${coords.x}px`;
        el.style.top = `${coords.y}px`;
        el.style.setProperty('--dx', coords.dx + 'px');
        const keyframesName = isToServer ? 'toRight' : 'toLeft';
        el.style.animation = `${keyframesName} ${Math.max(150, duration)}ms linear forwards`;
        overlay.appendChild(el);

        return new Promise((resolve) => {
          if (dropped) {
            const halfDuration = Math.max(100, Math.floor(duration / 2));
            setTimeout(() => {
              el.style.animation = `fadeOut 400ms linear forwards`;
              setTimeout(() => {
                el.remove();
                resolve({ dropped: true });
              }, 420);
            }, halfDuration);
          } else {
            setTimeout(() => {
              el.remove();
              resolve({ dropped: false });
            }, Math.max(150, duration) + 10);
          }
        });
      }

      function scpMessage(msgId, text) {
        return `SCP/1.0 | MSG | id=${msgId} | ${text}`;
      }

      function scpAck(msgId) {
        return `SCP/1.0 | ACK | id=${msgId} | MSG_RECEIVED`;
      }

      function clientSend(text) {
        const id = ++msgCounter;
        const formatted = scpMessage(id, text);
        appendConsole(clientConsole, formatted, `Client sent (id=${id})`);
        logEvent(`Client -> "${text}" (id=${id})`);

        const messageState = { id, text, retries: 0, acked: false, timer: null };
        activeMessages.set(id, messageState);
        attemptSend(id);
      }

      function attemptSend(id) {
        const state = activeMessages.get(id);
        if (!state) return;

        const maxRetries = parseInt(maxRetriesSelect.value, 10);
        if (state.retries > maxRetries) {
          appendConsole(clientConsole, `SCP_CLIENT | ERROR | id=${id} | MAX_RETRIES_EXCEEDED`, 'Client');
          logEvent(`Message id=${id} failed after ${state.retries} retries.`);
          activeMessages.delete(id);
          return;
        }

        state.retries += 1;
        appendConsole(clientConsole, `SCP/1.0 | SEND_ATTEMPT | id=${id} | try=${state.retries}`);
        logEvent(`Attempting send id=${id} (try ${state.retries})`);

        const delay = parseInt(delayRange.value, 10);
        const lossEnabled = lossToggle.checked;
        const lossPct = parseInt(lossRange.value, 10);
        const shouldDrop = lossEnabled && (Math.random() * 100) < lossPct;
        const travelDuration = Math.max(120, delay);

        animateFloating(scpMessage(id, state.text), { direction: 'toServer', duration: travelDuration });

        if (shouldDrop) {
          logEvent(`Message id=${id} was lost in transit (simulated).`);
          appendConsole(serverConsole, `-- packet loss occurred --`, 'Server');
          animateFloating(`dropped id=${id}`, { direction: 'toServer', duration: travelDuration, dropped: true });
        } else {
          setTimeout(() => {
            if (!activeMessages.has(id)) return;
            const raw = scpMessage(id, state.text);
            appendConsole(serverConsole, raw, `Server received (id=${id})`);
            logEvent(`Server received message id=${id}.`);

            const ackWillDrop = lossEnabled && (Math.random() * 100) < lossPct;
            const ackTravel = Math.max(120, delay);

            if (ackWillDrop) {
              logEvent(`ACK for id=${id} was lost in transit (simulated).`);
              animateFloating(`ACK_LOST id=${id}`, { direction: 'toClient', duration: ackTravel, dropped: true });
              appendConsole(serverConsole, scpAck(id), 'Server attempted ACK (lost)');
            } else {
              animateFloating(scpAck(id), { direction: 'toClient', duration: ackTravel, ack: true })
                .then(() => handleClientAck(id));
              appendConsole(serverConsole, scpAck(id), 'Server sent ACK');
              logEvent(`Server sent ACK for id=${id}.`);
            }
          }, travelDuration + 80);
        }

        if (state.timer) clearTimeout(state.timer);
        const ackTimeout = Math.max(200, parseInt(timeoutRange.value, 10));
        state.timer = setTimeout(() => {
          if (!activeMessages.has(id)) return;
          const s = activeMessages.get(id);
          if (s.acked) return;
          logEvent(`ACK timeout for id=${id} (try ${s.retries}).`);
          appendConsole(clientConsole, `SCP/1.0 | TIMEOUT | id=${id} | retrying...`, 'Client');
          attemptSend(id);
        }, ackTimeout + 20);
      }

      function handleClientAck(id) {
        const state = activeMessages.get(id);
        if (!state) {
          appendConsole(clientConsole, `SCP/1.0 | ACK_IGNORED | id=${id} | no active message`, 'Client');
          return;
        }
        state.acked = true;
        if (state.timer) {
          clearTimeout(state.timer);
          state.timer = null;
        }
        appendConsole(clientConsole, scpAck(id), 'Client received ACK');
        logEvent(`Client received ACK for id=${id}.`);
        activeMessages.delete(id);
      }

      sendForm.addEventListener('submit', (ev) => {
        ev.preventDefault();
        const text = input.value.trim();
        if (!text) return;
        clientSend(text);
        input.value = '';
      });

      clearLogBtn.addEventListener('click', () => {
        eventLog.innerHTML = '';
        clientConsole.innerHTML = '';
        serverConsole.innerHTML = '';
        activeMessages.clear();
        msgCounter = 0;
        logEvent('Logs cleared. Ready to send messages!');
      });

      // Initialize with a welcome message
      logEvent('Simulator ready! Type a message and click Send.');
    }

    // Initialize simulator when switching to that tab
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const targetTab = btn.dataset.tab;
        
        if (targetTab === 'simulator') {
          setTimeout(() => initSimulator(), 100);
        }
        
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(targetTab).classList.add('active');
        
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
    });

    // Initialize immediately if starting on simulator tab
    if (window.location.hash === '#simulator') {
      document.querySelector('[data-tab="simulator"]').click();
    }

    // File download functions
    function downloadFile(filename, content) {
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function getServerCode() {
      return `/*
 * scp_server.c - Simple Chat Protocol Server
 * Listens on port 8080 and handles SCP messages
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <time.h>

#define PORT 8080
#define BUFFER_SIZE 1024
#define MAX_CLIENTS 5

void parse_scp_message(char* buffer, char* msg_type, int* msg_id, char* payload) {
    char* token;
    char temp[BUFFER_SIZE];
    strcpy(temp, buffer);
    
    token = strtok(temp, "|");
    token = strtok(NULL, "|");
    if (token) sscanf(token, " %s", msg_type);
    
    token = strtok(NULL, "|");
    if (token) sscanf(token, " id=%d", msg_id);
    
    token = strtok(NULL, "|");
    if (token) strcpy(payload, token + 1);
}

void create_ack(char* buffer, int msg_id) {
    sprintf(buffer, "SCP/1.0 | ACK | id=%d | MSG_RECEIVED", msg_id);
}

void get_timestamp(char* buffer) {
    time_t now = time(NULL);
    struct tm* t = localtime(&now);
    sprintf(buffer, "%02d:%02d:%02d", t->tm_hour, t->tm_min, t->tm_sec);
}

int main() {
    int server_fd, client_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    char buffer[BUFFER_SIZE] = {0};
    char msg_type[50], payload[BUFFER_SIZE];
    int msg_id;
    char timestamp[20];
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Simple Chat Protocol (SCP) Server v1.0\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\\n");
    
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("Setsockopt failed");
        exit(EXIT_FAILURE);
    }
    
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
    
    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
        perror("Bind failed");
        exit(EXIT_FAILURE);
    }
    
    if (listen(server_fd, MAX_CLIENTS) < 0) {
        perror("Listen failed");
        exit(EXIT_FAILURE);
    }
    
    printf("ğŸŸ¢ Server listening on port %d...\\n\\n", PORT);
    
    if ((client_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {
        perror("Accept failed");
        exit(EXIT_FAILURE);
    }
    
    printf("âœ“ Client connected from %s:%d\\n\\n", inet_ntoa(address.sin_addr), ntohs(address.sin_port));
    
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        memset(msg_type, 0, sizeof(msg_type));
        memset(payload, 0, sizeof(payload));
        
        int bytes_read = read(client_socket, buffer, BUFFER_SIZE);
        if (bytes_read <= 0) {
            printf("Client disconnected\\n");
            break;
        }
        
        parse_scp_message(buffer, msg_type, &msg_id, payload);
        get_timestamp(timestamp);
        printf("[%s] RECV: %s\\n", timestamp, buffer);
        
        if (strcmp(msg_type, "HELLO") == 0) {
            printf("         â†’ Connection request from: %s\\n", payload);
            char ack[BUFFER_SIZE];
            create_ack(ack, msg_id);
            send(client_socket, ack, strlen(ack), 0);
            get_timestamp(timestamp);
            printf("[%s] SEND: %s\\n\\n", timestamp, ack);
        } else if (strcmp(msg_type, "MSG") == 0) {
            printf("         â†’ Message: %s\\n", payload);
            char ack[BUFFER_SIZE];
            create_ack(ack, msg_id);
            send(client_socket, ack, strlen(ack), 0);
            get_timestamp(timestamp);
            printf("[%s] SEND: %s\\n\\n", timestamp, ack);
        } else if (strcmp(msg_type, "BYE") == 0) {
            printf("         â†’ Client requesting disconnect\\n");
            char ack[BUFFER_SIZE];
            create_ack(ack, msg_id);
            send(client_socket, ack, strlen(ack), 0);
            get_timestamp(timestamp);
            printf("[%s] SEND: %s\\n\\n", timestamp, ack);
            printf("Connection closed by client\\n");
            break;
        } else {
            printf("         â†’ Unknown message type: %s\\n\\n", msg_type);
        }
    }
    
    close(client_socket);
    close(server_fd);
    
    printf("\\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Server shutdown complete\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    
    return 0;
}`;
    }

    function getClientCode() {
      return `/*
 * scp_client.c - Simple Chat Protocol Client
 * Connects to server and sends SCP messages with ACK handling
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <time.h>

#define PORT 8080
#define BUFFER_SIZE 1024
#define ACK_TIMEOUT 5
#define MAX_RETRIES 3

int message_id_counter = 0;

void get_timestamp(char* buffer) {
    time_t now = time(NULL);
    struct tm* t = localtime(&now);
    sprintf(buffer, "%02d:%02d:%02d", t->tm_hour, t->tm_min, t->tm_sec);
}

void create_scp_message(char* buffer, const char* msg_type, int msg_id, const char* payload) {
    sprintf(buffer, "SCP/1.0 | %s | id=%d | %s", msg_type, msg_id, payload);
}

int parse_ack(char* buffer) {
    int ack_id = -1;
    char* token = strtok(buffer, "|");
    while (token != NULL) {
        if (strstr(token, "id=") != NULL) {
            sscanf(token, " id=%d", &ack_id);
            break;
        }
        token = strtok(NULL, "|");
    }
    return ack_id;
}

int send_with_ack(int sock, const char* msg_type, const char* payload) {
    char send_buffer[BUFFER_SIZE];
    char recv_buffer[BUFFER_SIZE];
    char timestamp[20];
    int msg_id = message_id_counter++;
    int retries = 0;
    struct timeval tv;
    
    while (retries <= MAX_RETRIES) {
        create_scp_message(send_buffer, msg_type, msg_id, payload);
        get_timestamp(timestamp);
        printf("[%s] SEND (try %d): %s\\n", timestamp, retries + 1, send_buffer);
        send(sock, send_buffer, strlen(send_buffer), 0);
        
        tv.tv_sec = ACK_TIMEOUT;
        tv.tv_usec = 0;
        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        
        memset(recv_buffer, 0, BUFFER_SIZE);
        int bytes_read = read(sock, recv_buffer, BUFFER_SIZE);
        
        if (bytes_read > 0) {
            int ack_id = parse_ack(recv_buffer);
            get_timestamp(timestamp);
            printf("[%s] RECV: %s\\n", timestamp, recv_buffer);
            
            if (ack_id == msg_id) {
                printf("         âœ“ ACK received for id=%d\\n\\n", msg_id);
                return 1;
            } else {
                printf("         âœ— ACK mismatch (expected %d, got %d)\\n\\n", msg_id, ack_id);
            }
        } else {
            get_timestamp(timestamp);
            printf("[%s] âš  TIMEOUT: No ACK received for id=%d\\n", timestamp, msg_id);
            retries++;
            if (retries <= MAX_RETRIES) {
                printf("         â†’ Retrying... (%d/%d)\\n\\n", retries, MAX_RETRIES);
            }
        }
    }
    
    printf("         âœ— FAILED: Message delivery failed after %d retries\\n\\n", MAX_RETRIES);
    return 0;
}

int main() {
    int sock = 0;
    struct sockaddr_in serv_addr;
    char username[100];
    char message[BUFFER_SIZE];
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Simple Chat Protocol (SCP) Client v1.0\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\\n");
    
    printf("Enter your name: ");
    fgets(username, sizeof(username), stdin);
    username[strcspn(username, "\\n")] = 0;
    
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("\\nâœ— Socket creation error\\n");
        return -1;
    }
    
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);
    
    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
        printf("\\nâœ— Invalid address / Address not supported\\n");
        return -1;
    }
    
    printf("Connecting to server at 127.0.0.1:%d...\\n", PORT);
    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        printf("\\nâœ— Connection failed\\n");
        return -1;
    }
    
    printf("âœ“ Connected to server\\n\\n");
    
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
    printf("Sending connection request...\\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
    if (!send_with_ack(sock, "HELLO", username)) {
        printf("Failed to establish connection\\n");
        close(sock);
        return -1;
    }
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Chat session started\\n");
    printf("  Type 'quit' to exit\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\\n");
    
    while (1) {
        printf("You: ");
        fgets(message, BUFFER_SIZE, stdin);
        message[strcspn(message, "\\n")] = 0;
        
        if (strlen(message) == 0) continue;
        
        if (strcmp(message, "quit") == 0) {
            printf("\\nSending disconnect request...\\n");
            printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
            send_with_ack(sock, "BYE", "DISCONNECT");
            break;
        }
        
        printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
        send_with_ack(sock, "MSG", message);
    }
    
    close(sock);
    
    printf("\\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Disconnected from server\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    
    return 0;
}`;
    }

    function getMakefile() {
      return `# Makefile for Simple Chat Protocol (SCP)

CC = gcc
CFLAGS = -Wall -Wextra -std=c99
TARGET_SERVER = scp_server
TARGET_CLIENT = scp_client

all: $(TARGET_SERVER) $(TARGET_CLIENT)

$(TARGET_SERVER): scp_server.c
\t$(CC) $(CFLAGS) -o $(TARGET_SERVER) scp_server.c

$(TARGET_CLIENT): scp_client.c
\t$(CC) $(CFLAGS) -o $(TARGET_CLIENT) scp_client.c

clean:
\trm -f $(TARGET_SERVER) $(TARGET_CLIENT)

.PHONY: all clean`;
    }
  </script>
</body>
</html>
